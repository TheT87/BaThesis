
\chapter{Implementierung}%
\label{cha:implementation}

%In this chapter, you should provide technical details on how you actually implemented the design that you derived in the previous chapter.

% Comparative study and analysis of network intrusion detection tools

%\subsection{ Umsetzung/Implementierung der Taxonomie in  IDS-Signaturen}
%\section{Test der kontextsensitiven Signaturen}

%\subsection{ (Auswahl eines bereits existierenden/ Erstellung eines eigenen) Datensatzes + dazugehörige Label }
%\subsection{ Aufbau eines oder mehrerer Netzwerke  } 
%\subsection{ Setup der verschiedenen IDS }
%\subsection{ Grundlage mit non-kontextsensitiven Signaturen auf Datensatz }
%\subsection{ Test der kontextsensitiven Signaturen auf Datensatz} 

\section{Versuchsaufbau}
Der Ablauf für alle Anwendungsfälle ist grundsätzlich sehr ähnlich:
\begin{enumerate}
\item{Erzeugung des Netzwerkverkehrs}
\item{Mitschnitt des Netzwerkverkehrs}
\item{Analyse mittels Zeek-Skripts}
\item{Generierung von Logs}
\end{enumerate}
\subsection{Netzwerk}
Das Netzwerk besteht aus einem gleichbleibenden Endgerät in Form eines PC der als Ziel bzw. Endpunkt für den simulierten Netzwerkverkehr dient und verschiedenen anderen Teilnehmern bzw Angreifern. Die genauen Informationen der einzelnen Teilnehmer sind im jeweiligen Szenario genauer spezifiziert.
\subsection{Netzwerkverkehr}
\subsubsection{Erzeugung}
Der Netzwerkverkehr wurde mittels Scapy erzeugt. Das ermöglicht den für die verschiedenenen Szenarien benötigten Netzwerkverkehr zu erzeugen und die einzelnen Schichten eines Packets zur Verdeutlichung des jeweiligen Anwendungsfalls anzupassen. Für einzelne Skripte ist ausschnittsweise der erzeugte Netzwerkverkehr oder das dazugehörige Skript eingebunden. Eine Übersicht über alle dafür verwendeten Skripte findet sich im Anhang.
\subsubsection{Mitschneiden}
Der Netzwerkverkehr wurde mittels WireShark mitgeschnitten.
\subsection{Zeek}
%TODO
%Zeek is a passive, open-source network traffic analyzer. Many operators use Zeek as a network security monitor (NSM) to support investigations of suspicious or malicious activity.
%Zeek is a fully customizable and extensible platform for traffic analysis. Zeek provides users a domain-specific, Turing-complete scripting language for expressing arbitrary analysis tasks
%In brief, Zeek is optimized for interpreting network traffic and generating logs based on that traffic. It is not optimized for byte matching, and users seeking signature detection approaches would be better served by trying intrusion detection systems such as Suricata. Zeek is also not a protocol analyzer in the sense of Wireshark, seeking to depict every element of network traffic at the frame level, or a system for storing traffic in packet capture (PCAP) form. Rather, Zeek sits at the “happy medium” representing compact yet high fidelity network logs, generating better understanding of network traffic and usage.
%Zeek as a NSM platform enables collection of at least two, and in some ways three, of these data forms, namely transaction data, extracted content, and alert data
Zeek ist ein passiver, quelloffener Netzwerk-Traffic-Analysator und eine vollständig anpassbare und erweiterbare Plattform für die Traffic-Analyse. Zeek bietet eine domänenspezifische, Turing-komplette Skriptsprache zur Formulierung beliebiger Analyseaufgaben. Kurz gesagt, Zeek ist für die Interpretation von Netzwerkverkehr und die Erstellung von Protokollen auf der Grundlage dieses Verkehrs optimiert. Es ist nicht für den Byte-Abgleich optimiert, und Benutzer, die einen Ansatz zur Erkennung von Signaturen suchen, sind mit Systemen zur Erkennung von Eindringlingen wie Suricata besser bedient. Zeek ist auch kein Protokollanalysator im Sinne von Wireshark, der versucht, jedes Element des Netzwerkverkehrs auf Frame-Ebene darzustellen, oder ein System zur Speicherung von Datenverkehr in Form von Paketerfassung (PCAP). Vielmehr befindet sich Zeek in der "goldenen Mitte" und stellt kompakte, aber dennoch detailgetreue Netzwerkprotokolle dar, die ein besseres Verständnis des Netzwerkverkehrs und der Netzwerknutzung ermöglichen.
Zeek als NSM-Plattform ermöglicht die Erfassung von mindestens zwei, in gewisser Weise sogar drei dieser Datenformen, nämlich Transaktionsdaten, extrahierte Inhalte und Alarmdaten

Übersetzt mit www.DeepL.com/Translator (kostenlose Version)
\section{Skripte}
\subsection{Geografische Koordinaten und Ortszeit}
Das Volumen von durch Menschen verursachten Netzwerkverkehrs ist meist tageszeitabhängig. So wird in der Regel nachts weniger kommuniziert als am Tag.  Deshalb ist es sinnvoll den Grenzwert für erzeugten Verkehrsaufkommen ab dem ein Sender als potenziell böswillig eingestuft wird je nach Uhrzeit anzupassen.\\
\begin{figure}[h!]

\begin{lstlisting}[language=python]
def send_packet(ip_address):
    source_server = ip_address
    target_server = "172.17.144.87"

    # Send 10  packets
    for x in range(0, 15):
        port = random.randint(40000, 42000)
        layer_2 = Ether()
        layer_3 = IP(src=source_server, dst=target_server)
        layer_4 = TCP(sport=port,dport=port)
        tcp_pkt = layer_2 / layer_3 / layer_4
        sendp(tcp_pkt)
\end{lstlisting}
\caption{Erzeugen von Netzwerkverkehr}
\end{figure}

\begin{figure}[h!]
\begin{lstlisting}
function geolocation(c: connection):double{
	local origin_country = lookup_location(c$id$orig_h)$country_code;
	local origin_longitude = lookup_location(c$id$orig_h)$longitude;
	return origin_longitude;
}

function time_at_geolocation(longitude: double): int{
	#	1 degree of longitude is 4 minutes of time
	local time_difference  = (longitude - home_longitude)*240;
	local double_time_difference = time_to_double(network_time()) + time_difference;
	local epoch_time_difference = double_to_time(double_time_difference);
	local time_at_origin  = strftime("%H", epoch_time_difference);
	local useable_time_at_origin = to_int(time_at_origin);
	return useable_time_at_origin;
}

function set_threshold(c_time: int): double{
	if(c_time< opening_time || c_time > closing_time )
		threshold = threshold*0.5;
	else 
		threshold = threshold*1.1;
	return threshold;
}
\end{lstlisting}
\caption{Setzen des Grenzwertes von Verbindungsversuchen}
\end{figure}
\subsection{Laufende Prozesse}
\subsection{Größe des Netzwerks}
\subsection{Rechte eines Nutzers}

\section{Angriffe}
\subsection{ARP-Spoofing}
\subsection{NAT-Slipstreaming}
\subsection{DoS/DDoS}
\subsection{}