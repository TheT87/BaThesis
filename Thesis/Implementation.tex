\chapter{Implementierung}%
\label{cha:implementation}

%In this chapter, you should provide technical details on how you actually implemented the design that you derived in the previous chapter.

% Comparative study and analysis of network intrusion detection tools

%\subsection{ Umsetzung/Implementierung der Taxonomie in  IDS-Signaturen}
%\section{Test der kontextsensitiven Signaturen}

%\subsection{ (Auswahl eines bereits existierenden/ Erstellung eines eigenen) Datensatzes + dazugehörige Label }
%\subsection{ Aufbau eines oder mehrerer Netzwerke  } 
%\subsection{ Setup der verschiedenen IDS }
%\subsection{ Grundlage mit non-kontextsensitiven Signaturen auf Datensatz}
%\subsection{ Test der kontextsensitiven Signaturen auf Datensatz} 

Der im Kapitel Design dargelegte Aufbau eines Netzwerkes findet sich auch in der Implementation wieder. Scapy, Wireshark und Zeek kümmern sich dabei mit um Kommunikation, zeek-agent um die Entitäten und der Autor um die Annahmen und daraus resultierenden Normen.
\section{Erläuterung der wichtigsten Komponenten}
Eine kurze Vorstellung der wichtigsten Komponenten der Implementierung insofern sie im Rahmen der einzelnen Schritte des Versuchsaufbaus
\subsection{Netzwerk}
Das Netzwerk besteht aus einem gleichbleibenden Endgerät das als Ziel bzw. Endpunkt für den simulierten Netzwerkverkehr dient und verschiedenen anderen Teilnehmern bzw Angreifern. Die genauen Informationen der einzelnen Entitäten sind im jeweiligen Szenario genauer spezifiziert.
\subsection{Zeek}
%TODO
%Zeek is a passive, open-source network traffic analyzer. Many operators use Zeek as a network security monitor (NSM) to support investigations of suspicious or malicious activity.
%Zeek is a fully customizable and extensible platform for traffic analysis. Zeek provides users a domain-specific, Turing-complete scripting language for expressing arbitrary analysis tasks
%In brief, Zeek is optimized for interpreting network traffic and generating logs based on that traffic. It is not optimized for byte matching, and users seeking signature detection approaches would be better served by trying intrusion detection systems such as Suricata. Zeek is also not a protocol analyzer in the sense of Wireshark, seeking to depict every element of network traffic at the frame level, or a system for storing traffic in packet capture (PCAP) form. Rather, Zeek sits at the “happy medium” representing compact yet high fidelity network logs, generating better understanding of network traffic and usage.
%Zeek as a NSM platform enables collection of at least two, and in some ways three, of these data forms, namely transaction data, extracted content, and alert data
Ein passives, quelloffenes Analysewerkzeug für Netzwerkverkehr das via eigener  Skriptsprache unter anderem folgendes ermöglicht:
\begin{enumerate}
\item{Implementierung beliebiger Analyseaufgaben}
\item{Interpretation von Netzwerkverkehr}
\item{Erstellung von Protokollen auf der Grundlage dieses Verkehrs}
\end{enumerate}
Zeek ist dabei weder rein signatur-basiert wie Suricata noch ausschließlich als Protokollanalysator im Sinne von Wireshark zu verstehen. Vielmehr handelt es sich bei Zeek um eine Mischung die eine kompakte, aber dennoch detailgetreue Darstellung von Netzwerkprotokollen ermöglicht. Dies erlaubt ein besseres Verständnis des Netzwerkverkehrs und der Netzwerknutzung \cite{zeek_about_page}.

\subsection{zeek-agent}
\cite{zeek_agent}

\section{Versuchsaufbau}
Der Ablauf für alle Anwendungsfälle ist grundsätzlich sehr ähnlich:
\begin{enumerate}
\item{Spezifikation der Netzwerkes}
\item{Erzeugung}
\item{Mitschnitt}
\item{Analyse}
\begin{enumerate}
\item{Einlesen von Netzwerkverkehr}
\item{Einbindung des zusätzlichen Kontextes}
\item{Logging}
\end{enumerate}
\end{enumerate}
\subsection{Erzeugung}
%\subsubsection{Scapy}
Der Netzwerkverkehr wurde mittels Scapy erzeugt. Das ermöglicht den für die verschiedenen Szenarien benötigten Netzwerkverkehr zu erzeugen und die einzelnen Schichten eines Packets an den jeweiligen Anwendungsfalls anzupassen. In \ref{Code_1} ist dieser Prozess auschnittsweise dargestellt. Eine Übersicht über alle dafür verwendeten Skripte findet sich im Anhang.
\begin{figure}[h!]
\label{Code_1}
\centering
\begin{lstlisting}[language=python]
def send_packet(ip_address_src,ip_address_dst):
    source_server = ip_address_src
    target_server = ip_address_dst
    layer_2 = Ether()
    layer_3 = IP(src=source_server, dst=target_server)
    layer_4 = TCP(sport=80,dport=43468)
    tcp_pkt = layer_2 / layer_3 / layer_4
    sendp(tcp_pkt)
\end{lstlisting}
\caption{Erzeugen und Senden eines Pakets}
\end{figure}
\subsection{Mitschnitt}
%\subsubsection{Wireshark}
Der Mitschitt der von Scapy versendeten Pakets erfolgt mit Wireshark. Die mitgeschnittenen Pakets werden im als pcap-Dateien gespeichert um das einlesen in Zeek zu ermöglichen.


%defining the format of your data, letting Zeek know that you wish to create a new log, and then calling the Log::write method to output log records.
\subsection{Logging}
In Zeek erfolgt das Schreiben in Logs immer nach dem selben Prinzip:
\begin{enumerate}
\item{Vor dem Ausführen eines Skriptes wird ein Log und die darin zu speichernden Informationen festgelegt}
\begin{figure}[H]
\label{log_1	}
\centering
\begin{lstlisting}
module ExampleModule;
export {
    # Create an ID for our new stream. By convention, this is called "LOG".
    redef enum Log::ID += { LOG };
    # Define the record type that will contain the data to log.
    type Info: record {
        timestamp: time		&log;
        id: connection_id	&log; 
        notice: string		&log;
    };
}
redef record connection += {
    # By convention, the name of this new field is the lowercase name
    # of the module.
    examplelog: Info &optional;
};
\end{lstlisting}
\caption{Definition des Formats der Log-Datei}
\end{figure}
\item{Sobald Zeek startet wird ein Log }
\begin{figure}[H]
\centering
\begin{lstlisting}
event zeek_init(){
	local c : connection;
	Log::create_stream(ExampleModule::LOG, [$columns=Info, $path="examplemodule"]);
	local record: ExampleLog::Info = [$ts=current_time(), $id=c$id, $notice="Example Notice"];
    # Store a copy of the data in the connection record so other
    # event handlers can access it.
    c$examplelog = record;
    Log::write(ExampleModule::LOG, rec);
}
\end{lstlisting}
\caption{Generierung einer Log-Datei mit Verbindungsinformationen}
\end{figure}
\end{enumerate}

\begin{figure}[H]
\centering
\begin{lstlisting}
module ExampleModule;
export {
    # Create an ID for our new stream. By convention, this is
    # called "LOG".
    redef enum Log::ID += { LOG };

    # Define the record type that will contain the data to log.
    type Info: record {
        timestamp: time		&log;
        id: connection_id	&log; 
        notice: string		&log;
    };
}

redef record connection += {
    # By convention, the name of this new field is the lowercase name
    # of the module.
    examplelog: Info &optional;
};
event zeek_init(){
	Log::create_stream(ExampleModule::LOG, [$columns=Info, $path="examplemodule"]);
	local record: ExampleLog::Info = [$ts=current_time(), $id=c$id, $notice="Example Notice"];
    # Store a copy of the data in the connection record so other
    # event handlers can access it.
    c$examplelog = record;
    Log::write(ExampleModule::LOG, rec);
}
\end{lstlisting}
\caption{Generierung einer Log-Datei mit Verbindungsinformationen}
\end{figure}
%\newpage
\newpage
\section{Skripte}
Der Kern der Implementierung sind Zeek Skripte. Hier werden die gesammelten Kontextinformationen verwendet. Nachfolgend werden für einige ausgewählte Kategorien Anwendungsfälle vorgestellt.

\subsection{SQL-Abfragen}
\subsection{Geografische Koordinaten und Ortszeit}
IP-Adressräume lassen sich aufgrund des Vergabeverfahrens größtenteils einem geographischen Ort zuordnen. Damit kann man den räumlichen Abstand zwischen verschiedenen Verbindungsteilnehmern ermitteln. Mithilfe der lokalen Uhrzeit in Kombination mit dem aus dem Abstand ermittelten Zeitunterschied kann man die Uhrzeit am Ursprung der Anfrage bestimmen. Das Volumen von durch Menschen verursachten Netzwerkverkehr ist meist tageszeitabhängig. So wird in der Regel nachts weniger kommuniziert als am Tag.  Deshalb ist es sinnvoll den Grenzwert für erzeugtes Verkehrsaufkommen, ab dem ein Sender als potenziell böswillig eingestuft wird, je nach Uhrzeit anzupassen.
\begin{figure}[H]
\begin{lstlisting}
function geolocation(c: connection):double{
	local origin_longitude = lookup_location(c$id$orig_h)$longitude;
	return origin_longitude;
}
...
event connection_attempt(c: connection){
	local origin = geolocation(c);
	local origin_time = time_at_geolocation(origin);
	local connection_attempt_threshold = set_threshold(origin_time);
	local count_connection_attempts_c = number_of_connection_attempts(c);
	log_exceeded_ips(c,connection_attempt_threshold,count_connection_attempts_c);
}
\end{lstlisting}
\caption{Setzen des Grenzwertes von Verbindungsversuchen}
\end{figure}
\subsection{Offene Ports}
%Verwendet werden Ports die die aktuell auf dem System laufenden Prozesse.
Wenn eine Verbindung oder der Versuch eine Verbindung zu etablieren, mit einem bestimmten Port des Systems als Ziel beobachtet wird ohne das ein Prozess gibt der diesem Port mittels zugeordnet werden kann, wird die Verbindung bzw. der Verbindungsversuch im dazugehörigen Log vermerkt.
\begin{enumerate}
\item{Das Skript erfagt bei den zeek-agents in regelmäßigen Abständen die auf Hostsystemen laufenden Prozesse und deren verwendete Ports}
\item{Eine Verbindungversuch zu einem System wird von Zeek beobachtet}
\item{Das Skript vergleicht den Zielport der Anfrage mit der Liste von Hostports}
\item{Abhängig vom Ergebnis wird eine Meldung geloggt}
\end{enumerate}


\begin{figure}
\begin{lstlisting}
global local_ports : table[int] of string ={
        [80] = "http",
        [22] = "ssh",
        [25552] = "application_1"
    };
event zeek_init(){
    local query_stmt = "SELECT users.name, users.is_admin, sockets.process, sockets.protocol, sockets.local_addr, sockets.local_port, sockets.remote_addr, sockets.remote_port FROM users JOIN processes ON users.uid=processes.uid JOIN sockets ON sockets.pid=processes.pid";
    local query_event = users_result;
    local query_schedule = 10 secs;
    local port_query = ZeekAgent::query([$sql_stmt=query_stmt,$event_=query_event,$schedule_=query_schedule]);
}

event users_result(ctx: ZeekAgent::Context, data: Columns){
    local connection_port = data$remote_port;
   	local new_entry : count = connection_port;
    local_ports[new_entry] = data$name;
}

function check_outgoing_connection(c:connection){
    local c_port = port_to_count(c$id$orig_p);
    local rec : PortCheck::Info;
    if(c_port !in local_ports){
        rec = [$ts=current_time(), $id=c$id, $notice="No Application using this port"];
        }
    c$portcheck = rec;
    Log::write(PortCheck::LOG, rec);
    
}
\end{lstlisting}
\caption{•}
\end{figure}
\subsection{DNS-Auflösung}
\subsection{Rechte eines Nutzers}
\subsection{}